"""
Hand crafted classes which should undoubtedly be autogenerated from the schema.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any, Protocol, dataclass_transform
import re

from attrs import asdict, field, filters, frozen
from url import URL

from bowtie import HOMEPAGE, exceptions

if TYPE_CHECKING:
    from collections.abc import Awaitable, Callable, Mapping, Sequence
    from typing import ClassVar, Self

    from structlog.stdlib import BoundLogger

    from bowtie._connectables import ConnectableId
    from bowtie._core import Dialect as _Dialect, DialectRunner, TestCase
    from bowtie._registry import Validator, ValidatorRegistry


#: A unique identifier for a test case within a run or report.
Seq = int | str

#: A JSON representation of the command
Message = dict[str, Any]


@frozen
class Unsuccessful:
    failed: list[TestResult] = field(factory=list["TestResult"])
    errored: list[ErroredTest] = field(factory=list["ErroredTest"])
    skipped: list[SkippedTest] = field(factory=list["SkippedTest"])

    def __add__(self, other: Unsuccessful):
        return Unsuccessful(
            failed=self.failed + other.failed,
            errored=self.errored + other.errored,
            skipped=self.skipped + other.skipped,
        )

    def __bool__(self) -> bool:  # sigh, typing nonsense
        return bool(self.failed or self.errored or self.skipped)

    def counts(self):
        return {k: len(v) for k, v in asdict(self).items()}

    @property
    def total(self):
        """
        Any test which was not a successful result, including skips.
        """
        return len(self.errored) + len(self.failed) + len(self.skipped)


@frozen
class SeqCase:
    seq: Seq
    case: TestCase

    def run(self, runner: DialectRunner) -> Awaitable[SeqResult]:
        try:
            schema_without_dialect = "$schema" not in self.case.schema
        except TypeError:  # we could either warn or not warn here seemingly...
            schema_without_dialect = False

        if schema_without_dialect:
            runner.schema_without_dialect(self.case.schema)

        run = Run(seq=self.seq, case=self.case.without_expected_results())  # type: ignore[reportCallIssue]
        return runner.validate(run, expected=self.case.expected_results())

    def serializable(self):
        return dict(seq=self.seq, case=self.case.serializable())

    def matches_dialect(self, dialect: _Dialect):
        # FIXME: This of course belongs in a JSON Schema library for traversing
        #        these metaschemas.
        resource = dialect.specification().create_resource(self.case.schema)
        metaschema_uri = dialect.uri
        while resource is not None:
            try:
                metaschema_uri = URL.parse(resource.contents["$schema"])  # type: ignore[reportIndexIssue]
            except (TypeError, LookupError):
                return True

            resource = self.case.registry.get(str(metaschema_uri))
        return metaschema_uri == dialect.uri


@frozen
class Started:
    implementation: dict[str, Any]
    version: int = field(
        validator=lambda _, __, got: exceptions.VersionMismatch.check(got),
    )


class Command[R](Protocol):
    def to_request(self, registry: ValidatorRegistry[Any]) -> Message: ...

    @staticmethod
    def from_response(
        response: Message,
        registry: ValidatorRegistry[Any],
    ) -> R: ...


def validated(validator: Validator[Any], instance: Any):
    exception = validator.validate(instance)
    if exception is not None:
        raise exceptions.ProtocolError() from exception  # FIXME
    return instance


def command[R](
    Response: Callable[..., R],
    name: str = "",
) -> Callable[
    [type],
    type[Command[R]],
]:
    @dataclass_transform(frozen_default=True, field_specifiers=(field,))
    def _command(cls: type) -> type[Command[R]]:
        nonlocal name
        if not name:
            name = re.sub(r"([a-z])([A-Z])", r"\1-\2", cls.__name__).lower()

        uri = URL.parse(f"tag:{HOMEPAGE.host_str},2023:ihop:command:{name}")
        response_schema = {"$ref": str(uri.with_fragment("response"))}

        def to_request(
            self: Command[R],
            registry: ValidatorRegistry[Any],
        ) -> Message:
            request = {"cmd": name, **asdict(self)}
            return validated(registry.for_uri(uri), request)

        @staticmethod
        def from_response(
            response: Message,
            registry: ValidatorRegistry[Any],
        ) -> R:
            validator = registry.for_schema(response_schema)
            return Response(**validated(validator, response))

        cls.to_request = to_request
        cls.from_response = from_response
        return frozen(cls)

    return _command


@command(Response=Started)
class Start:
    version: int


START_V1 = Start(version=1)  # type: ignore[reportCallIssue]


@frozen
class StartedDialect:
    ok: bool

    OK: ClassVar[Self]


StartedDialect.OK = StartedDialect(ok=True)


@command(Response=StartedDialect)
class Dialect:
    dialect: str


class AnyTestResult(Protocol):
    @property
    def description(self) -> str:
        """
        A single word to use when displaying this result.
        """
        ...

    @property
    def skipped(self) -> bool: ...

    @property
    def errored(self) -> bool: ...

    def serializable(self) -> Message: ...


@frozen
class TestResult:
    errored = False
    skipped = False

    valid: bool

    VALID: ClassVar[Self]
    INVALID: ClassVar[Self]

    @property
    def description(self):
        return "valid" if self.valid else "invalid"

    @classmethod
    def from_dict(cls, data: Message) -> AnyTestResult:
        if data.pop("skipped", False):
            return SkippedTest(**data)
        elif data.pop("errored", False):
            return ErroredTest(**data)
        return cls(valid=data["valid"])

    def serializable(self) -> Message:
        return asdict(self)


TestResult.VALID = TestResult(valid=True)
TestResult.INVALID = TestResult(valid=False)


@frozen
class SkippedTest:
    message: str | None = field(default=None)
    issue_url: str | None = field(default=None)

    errored = False
    skipped: bool = field(init=False, default=True)

    description = "skipped"

    @classmethod
    def in_skipped_case(cls):
        """
        A skipped test which mentions it is part of an entirely skipped case.
        """
        return cls(message="All tests in this test case were skipped.")

    def serializable(self) -> Message:
        return asdict(
            self,
            filter=lambda k, v: (
                k.name not in {"message", "issue_url"} or v is not None
            ),
        )


@frozen
class ErroredTest:
    context: dict[str, Any] = field(factory=dict[str, "Any"])

    errored: bool = field(init=False, default=True)
    skipped: bool = False

    description = "error"

    @classmethod
    def in_errored_case(cls):
        """
        A errored test which mentions it is part of an entirely errored case.
        """
        return cls(
            context=dict(message="All tests in this test case errored."),
        )

    def serializable(self) -> Message:
        return asdict(self)


class AnyCaseResult(Protocol):
    @property
    def results(self) -> Sequence[AnyTestResult] | None: ...

    def result_for(self, i: int) -> AnyTestResult: ...

    def log(self, log: BoundLogger) -> None: ...

    def unsuccessful(
        self,
        expected: Sequence[bool | None],
    ) -> Unsuccessful: ...

    def serializable(self) -> Message: ...


def _case_result(seq: Seq, **data: Any) -> tuple[Seq, int, AnyCaseResult]:
    # FIXME: If we can get our expected length here...
    match data:
        case {"errored": True, **data}:
            return seq, 0, CaseErrored(**data)
        case {"skipped": True, **skip}:
            return seq, 0, CaseSkipped(**skip)
        case data:
            result = CaseResult.from_results(**data)
            return seq, len(result.results), result


@frozen
class SeqResult:
    """
    A result along with its corresponding metadata.

    Contains the implementation an test case it corresponds to.

    Knows how long the result was *supposed* to be, and what the expected
    validation results were supposed to be if that information was provided at
    run-time.
    """

    seq: Seq
    implementation: ConnectableId

    result: AnyCaseResult
    expected: Sequence[bool | None]

    @classmethod
    def from_dict(
        cls,
        seq: Seq,
        implementation: str,
        expected: list[bool | None],
        **data: dict[str, Any],
    ):
        _, _, result = _case_result(seq=seq, **data)
        return cls(
            seq=seq,
            implementation=implementation,
            expected=expected,
            result=result,
        )

    def result_for(self, i: int) -> AnyTestResult:
        return self.result.result_for(i)

    def unsuccessful(self) -> Unsuccessful:
        return self.result.unsuccessful(expected=self.expected)

    def log_and_be_serialized(self, log: BoundLogger) -> Mapping[str, Any]:
        self.result.log(log)
        return self.serializable()

    def serializable(self):
        serializable = asdict(self, filter=filters.exclude("result"))
        serializable.update(self.result.serializable())
        return serializable


@frozen
class CaseResult:
    """
    A test case which at least was run by the implementation.
    """

    results: Sequence[AnyTestResult]

    @classmethod
    def from_results(cls, results: list[dict[str, Any]]):
        return cls(results=[TestResult.from_dict(t) for t in results])

    def serializable(self) -> Message:
        return dict(results=[result.serializable() for result in self.results])

    def result_for(self, i: int) -> AnyTestResult:
        return self.results[i]

    def unsuccessful(self, expected: Sequence[bool | None]) -> Unsuccessful:
        skipped, errored, failed = [], [], []
        for got, expecting in zip(self.results, expected):
            if got.skipped:
                skipped.append(got)  # type: ignore[reportArgumentType]
            elif got.errored:
                errored.append(got)  # type: ignore[reportArgumentType]
            elif expecting is not None and got != TestResult(valid=expecting):
                failed.append(got)  # type: ignore[reportArgumentType]
        return Unsuccessful(skipped=skipped, failed=failed, errored=errored)  # type: ignore[reportUnknownArgumentType]

    def log(self, log: BoundLogger):
        for result in self.results:
            if result.errored:
                log.error("", **result.context)  # type: ignore[reportGeneralTypeIssues, reportUnknownMemberType]


@frozen
class CaseErrored:
    """
    A full test case errored.
    """

    results = None

    context: Mapping[str, Any] = field()
    message: str = field(default="")
    caught: bool = field(default=True)
    errored: bool = field(default=True, init=False)

    @classmethod
    def uncaught(cls, message: str = "uncaught error", **context: Any):
        return cls(caught=False, message=message, context=context)

    def serializable(self):
        return asdict(self)

    def result_for(self, i: int) -> ErroredTest:
        return ErroredTest.in_errored_case()

    def unsuccessful(self, expected: Sequence[bool | None]) -> Unsuccessful:
        errored = [ErroredTest.in_errored_case() for _ in expected]
        return Unsuccessful(errored=errored)

    def log(self, log: BoundLogger):
        log.error(self.message, **self.context)


@frozen
class CaseSkipped:
    """
    A full test case was skipped.
    """

    results = None

    message: str | None = None
    issue_url: str | None = None
    skipped: bool = field(init=False, default=True)

    def serializable(self):
        return asdict(
            self,
            filter=lambda k, v: (
                k.name not in {"message", "issue_url"} or v is not None
            ),
        )

    def result_for(self, i: int) -> SkippedTest:
        return SkippedTest.in_skipped_case()

    def unsuccessful(self, expected: Sequence[bool | None]) -> Unsuccessful:
        skipped = [SkippedTest.in_skipped_case() for _ in expected]
        return Unsuccessful(skipped=skipped)

    def log(self, log: BoundLogger):
        log.info(self.message or "skipped case")


@frozen
class Empty:
    """
    An implementation didn't send a response.
    """

    results = None

    def result_for(self, i: int) -> ErroredTest:
        return ErroredTest.in_errored_case()

    def log(self, log: BoundLogger):
        log.error("No response")

    def unsuccessful(self, expected: Sequence[bool | None]) -> Unsuccessful:
        errored = [ErroredTest.in_errored_case() for _ in expected]
        return Unsuccessful(errored=errored)


@command(Response=_case_result)
class Run:
    seq: Seq
    case: dict[str, Any]


@command(Response=Empty)
class Stop:
    pass


STOP = Stop()

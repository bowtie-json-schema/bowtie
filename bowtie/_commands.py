"""
Hand crafted classes which should undoubtedly be autogenerated from the schema.
"""
from __future__ import annotations

from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    ClassVar,
    Iterable,
    Protocol,
    Type,
    TypeVar,
    cast,
)

try:
    from typing import dataclass_transform
except ImportError:
    from typing_extensions import dataclass_transform

import json

import attrs

from bowtie import exceptions

if TYPE_CHECKING:
    from bowtie import _report


@attrs.frozen
class Test:

    description: str
    instance: Any
    valid: bool | None = None


@attrs.frozen
class TestCase:

    description: str
    schema: Any
    tests: list[Test]
    comment: str | None = None
    registry: dict[str, Any] | None = None

    @classmethod
    def from_dict(cls, tests: Iterable[dict[str, Any]], **kwargs: Any):
        kwargs["tests"] = [Test(**test) for test in tests]
        return cls(**kwargs)

    def without_expected_results(self) -> dict[str, Any]:
        as_dict = {
            "tests": [
                attrs.asdict(test, filter=lambda k, _: k.name != "valid")
                for test in self.tests
            ],
        }
        as_dict.update(
            attrs.asdict(
                self,
                filter=lambda k, v: k.name != "tests"
                and (k.name not in {"comment", "registry"} or v is not None),
            ),
        )
        return as_dict


@attrs.frozen
class Started:

    implementation: dict[str, Any]
    ready: bool = attrs.field()
    version: int = attrs.field()

    @ready.validator  # type: ignore[reportGeneralTypeIssues]
    def _check_ready(self, _, ready: bool):
        if not ready:
            raise exceptions.ImplementationNotReady()

    @version.validator  # type: ignore[reportGeneralTypeIssues]
    def _check_version(self, _, version: int):
        if version != 1:
            raise exceptions.VersionMismatch(expected=1, got=version)


_R = TypeVar("_R", covariant=True)


class Command(Protocol[_R]):
    def to_request(self, validate: Callable[..., None]) -> dict[str, Any]:
        ...

    @staticmethod
    def from_response(
        response: bytes,
        validate: Callable[..., None],
    ) -> _R | None:
        ...


@dataclass_transform()
def command(
    name: str,
    Response: Callable[..., _R | None],
) -> Callable[[type], type[Command[_R]]]:

    request_schema = {"$ref": f"#/$defs/command/$defs/{name}"}
    response_schema = {"$ref": f"#/$defs/command/$defs/{name}/$defs/response"}

    def _command(cls: type) -> type[Command[_R]]:
        def to_request(
            self: Command[_R],
            validate: Callable[..., None],
        ) -> dict[str, Any]:
            request = dict(cmd=name, **attrs.asdict(self))
            validate(instance=request, schema=request_schema)
            return request

        @staticmethod
        def from_response(
            response: bytes,
            validate: Callable[..., None],
        ) -> _R | None:
            try:
                instance = json.loads(response)
            except json.JSONDecodeError as error:
                raise exceptions._ProtocolError(errors=[error])  # type: ignore[reportPrivateUsage]  # noqa: E501
            validate(instance=instance, schema=response_schema)
            return Response(**instance)

        cls = cast(Type[Command[_R]], cls)
        cls.to_request = to_request
        cls.from_response = from_response
        return attrs.frozen(cls)

    return _command


@command(name="start", Response=Started)
class Start:

    version: int


START_V1 = Start(version=1)


@attrs.frozen
class StartedDialect:

    ok: bool

    OK: ClassVar[StartedDialect]


StartedDialect.OK = StartedDialect(ok=True)


@command(name="dialect", Response=StartedDialect)
class Dialect:

    dialect: str


def _case_result(
    errored: bool = False,
    skipped: bool = False,
    **response: Any,
) -> Callable[[str, bool | None], CaseResult | CaseSkipped | CaseErrored]:
    if errored:
        return lambda implementation, expected: CaseErrored(
            implementation=implementation,
            **response,
        )
    elif skipped:
        return lambda implementation, expected: CaseSkipped(
            implementation=implementation,
            **response,
        )
    return lambda implementation, expected: CaseResult.from_dict(
        response,
        implementation=implementation,
        expected=expected,
    )


@attrs.frozen
class TestResult:

    errored = False
    skipped = False

    valid: bool

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
    ) -> TestResult | SkippedTest | ErroredTest:
        if data.pop("skipped", False):
            return SkippedTest(**data)
        elif data.pop("errored", False):
            return ErroredTest(**data)
        return cls(valid=data["valid"])


@attrs.frozen
class SkippedTest:

    message: str | None = attrs.field(default=None)
    issue_url: str | None = attrs.field(default=None)

    errored = False
    skipped: bool = attrs.field(init=False, default=True)

    @property
    def reason(self) -> str:
        if self.message is not None:
            return self.message
        if self.issue_url is not None:
            return self.issue_url
        return "skipped"


@attrs.frozen
class ErroredTest:

    context: dict[str, Any] = attrs.field(factory=dict)

    errored: bool = attrs.field(init=False, default=True)
    skipped: bool = False

    @property
    def reason(self) -> str:
        message = self.context.get("message")
        if message:
            return message
        return "Encountered an error."


class ReportableResult(Protocol):

    errored: bool

    def report(self, reporter: _report._CaseReporter) -> None:  # type: ignore[reportPrivateUsage]  # noqa: E501
        pass


@attrs.frozen
class CaseResult:

    errored = False

    implementation: str
    seq: int
    results: list[TestResult | SkippedTest | ErroredTest]
    expected: list[bool | None]

    @classmethod
    def from_dict(cls, data: Any, **kwargs: Any):
        return cls(
            results=[TestResult.from_dict(t) for t in data.pop("results")],
            **data,
            **kwargs,
        )

    @property
    def failed(self) -> bool:
        return any(failed for _, failed in self.compare())

    def report(self, reporter: _report._CaseReporter) -> None:  # type: ignore[reportPrivateUsage]  # noqa: E501
        reporter.got_results(self)

    def compare(
        self,
    ) -> Iterable[tuple[TestResult | SkippedTest | ErroredTest, bool]]:
        for test, expected in zip(self.results, self.expected):
            failed: bool = (  # type: ignore[reportUnknownVariableType]
                not test.skipped
                and not test.errored
                and expected is not None
                and expected != test.valid  # type: ignore[reportUnknownMemberType]  # noqa: E501
            )
            yield test, failed


@attrs.frozen
class CaseErrored:

    errored = True

    implementation: str
    seq: int
    context: dict[str, Any]

    caught: bool = True

    def report(self, reporter: _report._CaseReporter):  # type: ignore[reportPrivateUsage]  # noqa: E501
        reporter.errored(self)

    @classmethod
    def uncaught(cls, implementation: str, seq: int, **context: Any):
        return cls(
            implementation=implementation,
            seq=seq,
            caught=False,
            context=context,
        )


@attrs.frozen
class CaseSkipped:

    errored = False

    implementation: str
    seq: int

    message: str | None = None
    issue_url: str | None = None
    skipped: bool = attrs.field(init=False, default=True)

    def report(self, reporter: _report._CaseReporter):  # type: ignore[reportPrivateUsage]  # noqa: E501
        reporter.skipped(self)


@attrs.frozen
class Empty:
    """
    An implementation didn't send a response.
    """

    errored = True

    implementation: str

    def report(self, reporter: _report._CaseReporter):  # type: ignore[reportPrivateUsage]  # noqa: E501
        reporter.no_response(implementation=self.implementation)


@command(name="run", Response=_case_result)
class Run:

    seq: int
    case: dict[str, Any]


@command(name="stop", Response=lambda: None)
class Stop:
    pass


STOP = Stop()
